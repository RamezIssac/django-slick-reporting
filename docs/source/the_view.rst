.. _customization:

The Slick Report View and form
===============================

What is SlickReportView?
-----------------------

SlickReportView is a CBV that inherits form ``FromView`` and expose the report generator needed attributes.
Also

* Auto generate the search form
* return the results as a json response if ajax request
* Works on GET and POST
* Export to CSV (extendable to apply other exporting method)


How the search form is generated ?
-----------------------------------
Behind the scene, Sample report calls ``slick_reporting.form_factory.report_form_factory``
a helper method which generates a form containing start date and end date, as well as all foreign keys on the report_model.


Export to CSV
--------------
To trigger an export to CSV, just add ``?_export=csv`` to the url.
This will call the export_csv on the view class, engaging a `ExportToStreamingCSV`

You can extend the functionality, say you want to export to pdf.
Add a ``export_pdf`` method to the view class, accepting the report_data json response and return the response you want.
This ``export_pdf` will be called automatically when url parameter contain ``?_export=pdf``

Having an `_export` parameter not implemented, to say the view class do not implement ``export_{parameter_name}``,  will be ignored.

SlickReportingListView
-----------------------
This is a simple ListView to display data in a model, like you would with an admin ChangeList view.
It's a simple ListView with a few extra features:

filters: a list of report_model fields to be used as filters.



Override the Form
------------------

The default form is generated by ``slick_reporting.form_factory.report_form_factory``.

The system expect the form to implement the ``slick_reporting.forms.BaseReportForm`` interface.

The methods to implement are:

* ``get_filters``: return a tuple (Q_filers , kwargs filter) to be used in filtering.
  q_filter: can be none or a series of Django's Q queries
  kwargs_filter: None or a dictionary of filters

* ``get_start_date``: return the start date of the report.

* ``get_end_date``: return the end date of the report.

* ``get_crispy_helper`` : return a crispy form helper to be used in rendering the form. (optional)

In case you are working with a crosstab report, you need to implement the following methods:

* ``get_crosstab_compute_remainder``: return a boolean indicating if the remainder should be computed or not.

* ``get_crosstab_ids``: return a list of ids to be used in the crosstab report.


And in case you are working with a time series report, with a selector on, you need to implement the following method:

* ``get_time_series_pattern``: return a string representing the time series pattern. ie: ``ie: daily, monthly, yearly``

Example:

.. code-block:: python

    # forms.py
    from slick_reporting.forms import BaseReportForm

    # Inherit from BaseReportForm
    class RequestLogForm(BaseReportForm, forms.Form):

        SECURE_CHOICES = (
            ("all", "All"),
            ("secure", "Secure"),
            ("non-secure", "Not Secure"),
        )

        start_date = forms.DateField(
            required=False,
            label="Start Date",
            widget=forms.DateInput(attrs={"type": "date"}),
        )
        end_date = forms.DateField(
            required=False, label="End Date", widget=forms.DateInput(attrs={"type": "date"})
        )
        secure = forms.ChoiceField(
            choices=SECURE_CHOICES, required=False, label="Secure", initial="all"
        )
        method = forms.CharField(required=False, label="Method")
        response = forms.ChoiceField(
            choices=HTTP_STATUS_CODES,
            required=False,
            label="Response",
            initial="200",
        )
        other_people_only = forms.BooleanField(
            required=False, label="Show requests from other People Only"
        )

        def __init__(self, request=None, *args, **kwargs):
            self.request = request
            super(RequestLogForm, self).__init__(*args, **kwargs)
            # provide initial values and ay needed customization
            self.fields["start_date"].initial = datetime.date.today()
            self.fields["end_date"].initial = datetime.date.today()

        def get_filters(self):
            # return the filters to be used in the report
            # Note the use of Q filters and kwargs filters
            filters = {}
            q_filters = []
            if self.cleaned_data["secure"] == "secure":
                filters["is_secure"] = True
            elif self.cleaned_data["secure"] == "non-secure":
                filters["is_secure"] = False
            if self.cleaned_data["method"]:
                filters["method"] = self.cleaned_data["method"]
            if self.cleaned_data["response"]:
                filters["response"] = self.cleaned_data["response"]
            if self.cleaned_data["other_people_only"]:
                q_filters.append(~Q(user=self.request.user))

            return q_filters, filters

        def get_start_date(self):
            return self.cleaned_data["start_date"]

        def get_end_date(self):
            return self.cleaned_data["end_date"]

        # reports.py

        @register_report_view
        class RequestCountByPath(ReportView):
            form_class = RequestLogForm


Charting
---------

Charts settings is a list of objects which each object represent a chart configurations.

* type: what kind of chart it is: Possible options are bar, pie, line and others subject of the underlying charting engine.
  Hats off to : `Charts.js <https://www.chartjs.org/>`_.
* engine_name: String, default to ``SLICK_REPORTING_DEFAULT_CHARTS_ENGINE``. Passed to front end in order to use the appropriate chart engine.
  By default supports `highcharts` & `chartsjs`.
* data_source: Field name containing the numbers we want to plot.
* title_source: Field name containing labels of the data_source
* title: the Chart title. Defaults to the `report_title`.
* plot_total if True the chart will plot the total of the columns. Useful with time series and crosstab reports.

On front end, for each chart needed we pass the whole response to the relevant chart helper function and it handles the rest.

The ajax response structure
---------------------------

Understanding how the response is structured is imperative in order to customize how the report is displayed on the front end.

Let's have a look

.. code-block:: python


    # Ajax response or `report_results` template context variable.
    response = {
        # the report slug, defaults to the class name all lower
        "report_slug": "",

        # a list of objects representing the actual results of the report
        "data": [
            {"name": "Product 0", "quantity__sum": "1774", "value__sum": "8758", "field_n" : "value_n"},
            # .....
        ],

        # A list explaining the columns/keys in the data results.
        # ie: len(response.columns) == len(response.data[i].keys())
        # Contains needed information about the verbose name , if summable , hints about the data type.
        "columns": [
            {"name": "name",
             "computation_field": "",
             "verbose_name": "Name",
             "visible": True,
             "type": "CharField",
             "is_summable": False
             },
            {"name": "quantity__sum",
             "computation_field": "",
             "verbose_name": "Quantities Sold",
             "visible": True,
             "type": "number",
             "is_summable": True},
            {"name": "value__sum",
             "computation_field": "",
             "verbose_name": "Value $",
             "visible": True,
             "type": "number",
             "is_summable": True}
        ],

        # Contains information about the report as whole if it's time series or a a crosstab
        # And what's the actual and verbose names of the time series or crosstab specific columns.
        "metadata": {"time_series_pattern": "",
                     "time_series_column_names": [],
                     "time_series_column_verbose_names": [],
                     "crosstab_model": '',
                     "crosstab_column_names": [],
                     "crosstab_column_verbose_names": []
                     },


        # a mirror of the set charts_settings on the SlickReportView
        # SlickReportView populates the id if missing and fill the `engine_name' if not set
        "chart_settings": [
            {"type": "pie",
            'engine_name': 'highcharts',
             "data_source": ["quantity__sum"],
             "title_source": ["name"],
             "title": "Pie Chart (Quantities)",
             "id": "pie-0"},

            {"type": "bar",
            "engine_name": "chartsjs",
            "data_source": ["value__sum"],
            "title_source": ["name"],
            "title": "Column Chart (Values)",
             "id": "bar-1"}
        ]
    }


